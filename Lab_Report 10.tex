\documentclass[11pt]{article}            % Report class in 11 points
\parindent0pt  \parskip10pt             % make block paragraphs
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {images/} }
\usepackage{graphicx} %  graphics header file
\begin{document}
\begin{titlepage}
    \centering
  \vfill
    \includegraphics[width=8cm]{uni_logo.png} \\ 
	\vskip2cm
    {\bfseries\Large
	Data Structuers and algorithms \\ (CS09203)\\
	
	\vskip2cm
	Lab Report 
	 
	\vskip2cm
	}    

\begin{center}
\begin{tabular}{ l l  } 

Name: & Fatima komal \\ 
Registration \#: & SEU-F16-143 \\ 
Lab Report \#: & 10 \\ 
 Dated:& 16-04-2018\\ 
Submitted To:& Mr. Usman Ahmed\\ 

 %\hline
\end{tabular}
\end{center}
    \vfill
    The University of Lahore, Islamabad Campus\\
Department of Computer Science \& Information Technology
\end{titlepage}


    
    {\bfseries\Large
\centering
	Experiment \# 10 \\

BFS Graph and its representationsl \\
	
	}    
 \vskip1cm
 \textbf {Objective}\\ The objective of this session is to show the representation of graphs using C++. 
 
 \textbf {Software Tool} \\
 1. Code Blocks with GCC compiler.

\section{Theory }              

Breadth First Traversal (or Search) for a graph is similar to Breadth First Traversal of a tree. The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array. For simplicity, it is assumed that all vertices are reachable from the starting vertex.
\section{Task}  

\subsection{ Task 1 }     

Impement Breadth First Traversal (or Search) for a graph

\subsection{Procedure: Task 1 }    
 

\begin{lstlisting}


#include<iostream>
#include<queue>
using namespace std;

struct Node {
	char data;
	Node *left;
	Node *right;
};

void LevelOrder(Node *root) {
	if(root == NULL) return;
	queue<Node*> Q;
	Q.push(root);  

	while(!Q.empty()) {
		Node* current = Q.front();
		Q.pop(); 
		cout<<current->data<<" ";
		if(current->left != NULL) Q.push(current->left);
		if(current->right != NULL) Q.push(current->right);
	}
}
Node* Insert(Node *root,char data) {
	if(root == NULL) {
		root = new Node();
		root->data = data;
		root->left = root->right = NULL;
	}
	else if(data <= root->data) root->left = Insert(root->left,data);
	else root->right = Insert(root->right,data);
	return root;
}

int main() {

	Node* root = NULL;
	root = Insert(root,'M'); root = Insert(root,'B');
	root = Insert(root,'Q'); root = Insert(root,'Z'); 
	root = Insert(root,'A'); root = Insert(root,'C');

	LevelOrder(root);
}





\end{lstlisting}
\begin{figure*}
\centering
  \includegraphics[width=12cm,height=6cm,keepaspectratio]{10.png}
\caption{output}
\label{Figure:3}    
\end{figure*} 




 
\end{document}                          % The required last line
