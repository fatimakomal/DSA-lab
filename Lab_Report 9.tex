\documentclass[11pt]{article}            % Report class in 11 points
\parindent0pt  \parskip10pt             % make block paragraphs
\usepackage{graphicx}
\usepackage{listings}
\graphicspath{ {images/} }
\usepackage{graphicx} %  graphics header file
\begin{document}
\begin{titlepage}
    \centering
  \vfill
    \includegraphics[width=8cm]{uni_logo.png} \\ 
	\vskip2cm
    {\bfseries\Large
	Data Structuers and algorithms \\ (CS09203)\\
	
	\vskip2cm
	Lab Report 
	 
	\vskip2cm
	}    

\begin{center}
\begin{tabular}{ l l  } 

Name: & Fatima komal \\ 
Registration \#: & SEU-F16-143 \\ 
Lab Report \#: & 09 \\ 
 Dated:& 16-04-2018\\ 
Submitted To:& Mr. Usman Ahmed\\ 

 %\hline
\end{tabular}
\end{center}
    \vfill
    The University of Lahore, Islamabad Campus\\
Department of Computer Science \& Information Technology
\end{titlepage}


    
    {\bfseries\Large
\centering
	Experiment \# 9 \\

DFS Graph and its representationsl \\
	
	}    
 \vskip1cm
 \textbf {Objective}\\ The objective of this session is to show the representation of graphs using C++. 
 
 \textbf {Software Tool} \\
 1. Code Blocks with GCC compiler.

\section{Theory }              

Depth First Traversal (or Search) for a graph is similar to Depth First Traversal of a tree. The only catch here is, unlike trees, graphs may contain cycles, so we may come to the same node again. To avoid processing a node more than once, we use a boolean visited array.
\section{Task}  

\subsection{ Task 1 }     

Impeiment Depth First Traversal (or Search) for a graph.

\subsection{Procedure: Task 1 }    
 

\begin{lstlisting}

#include<iostream>
using namespace std;
struct node{
	char data;
	struct node* left;
	struct node* right;
};

void Preorder(struct node *root){
	if(root == NULL)	return;
	cout<<root->data<<" ";
	Preorder(root->left);
	Preorder(root->right);
}

void Inorder(struct node *root){
	 if(root == NULL)	return;
	 Inorder(root->left);
	 cout<<root->data<<" ";
	 Inorder(root->right);
}

void Postorder(struct node *root){
	if(root == NULL)	return;
	Postorder(root->left);
	Postorder(root->right);
	cout<<root->data<<" ";
}

node* Insert(node *root, char data){
	if(root == NULL){
		root = new node();
		root->data = data;
		root->left = root->right = NULL;
	}
	else if(data <= root->data)
		root->left = Insert(root->left, data);
	else
		root->right = Insert(root->right, data);
	return root;
}

int main(){
	node* root = NULL;
	root = Insert(root, 'M');	root = Insert(root, 'B');
	root = Insert(root, 'Q');	root = Insert(root, 'Z');
	root = Insert(root, 'A');	root = Insert(root, 'C');
	
	cout<<"Preorder: ";
	Preorder(root);
	cout<<"\n";
	cout<<"Postorder: ";
	Postorder(root);
	cout<<"\n";
	cout<<"Inorder: ";
	Inorder(root);
	cout<<"\n";
}





\end{lstlisting}
\begin{figure*}
\centering
  \includegraphics[width=12cm,height=6cm,keepaspectratio]{9.png}
\caption{output}
\label{Figure:3}    
\end{figure*} 




 
\end{document}                          % The required last line
